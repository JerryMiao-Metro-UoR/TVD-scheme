import numpy as np
import matplotlib.pyplot as plt

def calculate_total_variation(phi):
    """total variation"""
    return np.sum(np.abs(np.diff(phi)))

def run_simulation_and_track_tv(method, phi_initial, c, n_steps, method_name, limiter_name=None):
    """
    Parameters:
        phi_initial: initioal condition
        c: Courant
        n_steps: time step
        method name
        limiter name
    """
    # copy initial conditions
    if method == CTCS:
        # CTCS need two time layers
        phi = [phi_initial.copy(), phi_initial.copy()]
    else:
        phi = [phi_initial.copy()]
    
    tv_history = [calculate_total_variation(phi_initial)]
    
    print(f"\n=== {method_name} TV track ===")
    print(f"initial TV: {tv_history[0]:.6f}")
    
    for step in range(n_steps):
        if limiter_name:
            method(phi, c, limiter_name)
        else:
            method(phi, c)
        
        current_tv = calculate_total_variation(phi[-1])
        tv_history.append(current_tv)
        
        if step % 5 == 0:  # every five steps, can be changed
            change = current_tv - tv_history[0]
            change_percent = (change / tv_history[0]) * 100
            print(f"step count {step:2d}: TV = {current_tv:.6f} (change: {change:+.6f}, {change_percent:+.2f}%)")
    
    final_change = tv_history[-1] - tv_history[0]
    final_change_percent = (final_change / tv_history[0]) * 100
    print(f"final: TV = {tv_history[-1]:.6f} (change in all: {final_change:+.6f}, {final_change_percent:+.2f}%)")
    
    return tv_history, phi[-1]

def compare_methods():
    """TV comparision"""

    nx = 500
    c = 0.7  # Courant
    n_steps = 20
    
    # an attempt on squarewave
    x = np.linspace(0, 1, nx)
    phi_initial = np.zeros(nx)
    phi_initial[nx//4:3*nx//4] = 1.0  # squarewave
    
    print("initial: square wave")
    print(f"grids: {nx}, Courant: {c}, time steps: {n_steps}")
    print(f"initial TV: {calculate_total_variation(phi_initial):.6f}")
    
    # test of metiods
    methods = [
        (FTBS, "FTBS", None),
        #(FTCS, "FTCS", None),
        (CTCS, "CTCS", None),
        (TVD_upwind, "TVD-minmod", 'minmod'),
        (TVD_upwind, "TVD-superbee", 'superbee'),
        (TVD_upwind, "TVD-vanleer", 'vanleer'),
    ]
    
    tv_histories = {}
    final_states = {}
    
    for method, name, limiter in methods:
        tv_history, final_state = run_simulation_and_track_tv(
            method, phi_initial, c, n_steps, name, limiter
        )
        tv_histories[name] = tv_history
        final_states[name] = final_state
    
    # tv variation
    plt.figure(figsize=(15, 10))
    
    # final status
    plt.subplot(2, 1, 1)
    plt.plot(x, phi_initial, 'k-', label="initial condition", linewidth=3, alpha=0.7)

    cols = ['blue', 'red', 'green', 'cyan', 'magenta', 'brown', 'purple',
            'pink', 'orange', 'gray', 'orange']

    for i, (name, final_state) in enumerate(final_states.items()):
        plt.plot(x, final_state, cols[i], label=name, linewidth=1.5)
    
    plt.xlabel('position x')
    plt.ylabel('Ï†')
    plt.title('Final States Comparison - Square Wave')
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.xlim([0, 1])
    
    # TVD comparosion
    plt.subplot(2, 1, 2)
    for i, (name, tv_history) in enumerate(tv_histories.items()):
        plt.plot(range(len(tv_history)), tv_history, cols[i], label=name, linewidth=2)
    
    plt.axhline(y=tv_histories['FTBS'][0], color='black', linestyle='--', 
                alpha=0.5, label='initial TV')
    plt.xlabel('time step')
    plt.ylabel('Total Variation')
    plt.title('Total Variation Evolution - Square Wave')
    plt.legend()
    plt.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()
    
    return tv_histories, final_states

# maintain
def FTBS(phi, c):
    phi.append(phi[-1].copy())
    phiOld = phi[0]
    phiNew = phi[1]
    
    nx = len(phiOld)
    for i in range(nx):
        phiNew[i] = phiOld[i] - c*(phiOld[i] - phiOld[(i-1)%nx])
    
    phi.pop(0)
    return None

def FTCS(phi, c):
    phi.append(phi[-1].copy())
    phiOld = phi[0]
    phiNew = phi[1]
    
    nx = len(phiOld)
    for i in range(nx):
        phiNew[i] = phiOld[i] - 0.5*c*(phiOld[(i+1)%nx] - phiOld[(i-1)%nx])
    
    phi.pop(0)
    return None

def CTCS(phi, c):
    if len(phi) == 1:
        phiOld = phi[0].copy()
        FTCS(phi, c)
        phi.insert(0, phiOld)
        return None
    
    phi.append(phi[0].copy())
    phiOld = phi[0]
    phiMid = phi[1]
    phiNew = phi[2]
    
    nx = len(phiOld)
    for i in range(nx):
        phiNew[i] = phiOld[i] - c*(phiMid[(i+1)%nx] - phiMid[(i-1)%nx])
    
    phi.pop(0)
    return None

def minmod(r):
    return np.maximum(0, np.minimum(1, r))

def superbee(r):
    return np.maximum(0, np.maximum(np.minimum(2*r,1), np.minimum(r,2)))

def vanleer(r):
    return (r + np.abs(r)) / (1 + np.abs(r) + 1e-12)

def vanalbada(r):
    return (r*(1 + r)) / (1 + r*r + 1e-12)

def TVD_upwind(phi_list, c, limiter_name='minmod'):
    if limiter_name == 'minmod':
        limiter = minmod
    elif limiter_name == 'superbee':
        limiter = superbee
    elif limiter_name == 'vanleer':
        limiter = vanleer
    elif limiter_name == 'vanalbada':
        limiter = vanalbada
    else:
        raise ValueError("Unknown limiter")

    phi = phi_list[-1].copy()
    nx = len(phi)
    
    phi_im1 = np.roll(phi, 1)
    phi_ip1 = np.roll(phi, -1)
    
    eps = 1e-12
    r = (phi - phi_im1) / (phi_ip1 - phi + eps)
    
    phi_lim = limiter(r)
    
    if c >= 0:
        phi_L = phi + 0.5 * phi_lim * (phi_ip1 - phi)
        flux = phi_L
    else:
        phi_R = phi_ip1 - 0.5 * phi_lim * (phi_ip1 - phi)
        flux = phi_R
    
    phi_new = phi - c * (flux - np.roll(flux, 1))
    
    phi_list.append(phi_new)
    if len(phi_list) > 1:
        phi_list.pop(0)
    
    return None

c = 0.5      # balanced accuracy and stability
nx = 200     
n_steps = 50 # reasonble 
limiter = 'vanleer'  # balanced choice

if __name__ == "__main__":
    tv_histories, final_states = compare_methods()
    

